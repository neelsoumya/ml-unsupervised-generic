---
title: "PCA Failure Demo"
format: html
---

<!-- Raw HTML block: we'll mount a React app here -->
<div id="pca-root"></div>

<!-- quick styling via Tailwind CDN for the classes used in your component -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- React & ReactDOM UMD builds -->
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

<!-- Babel (for JSX in-browser) - OK for demos -->
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<!-- mathjs UMD (provides global `math`) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>

<!-- Your component code, using type="text/babel" so Babel compiles JSX -->
<script type="text/babel">
/* Remove ES module imports; use global React, ReactDOM, math */

// Use React hooks via global React
const { useState, useEffect } = React;

function PCAFailureDemo() {
  const [activeDataset, setActiveDataset] = useState('horseshoe');
  const [showPCA, setShowPCA] = useState(false);
  const [data, setData] = useState([]);
  const [pcaResults, setPcaResults] = useState(null);

  // Generate horseshoe data
  const generateHorseshoeData = (n = 200) => {
    const arr = [];
    for (let i = 0; i < n; i++) {
      const t = (i / n) * Math.PI; // from 0 to π
      const noise = 0.1;
      const x = Math.cos(t) + (Math.random() - 0.5) * noise;
      const y = Math.sin(t) + (Math.random() - 0.5) * noise;
      arr.push({ x, y, original: true });
    }
    return arr;
  };

  // Generate spiral time series data
  const generateSpiralData = (n = 200) => {
    const arr = [];
    for (let i = 0; i < n; i++) {
      const t = (i / n) * 4 * Math.PI; // 2 full spirals
      const r = 0.5 + (i / n) * 2; // increasing radius
      const noise = 0.05;
      const x = r * Math.cos(t) + (Math.random() - 0.5) * noise;
      const y = r * Math.sin(t) + (Math.random() - 0.5) * noise;
      arr.push({ x, y, original: true });
    }
    return arr;
  };

  // Generate sine wave time series data
  const generateTimeSeriesData = (n = 200) => {
    const arr = [];
    for (let i = 0; i < n; i++) {
      const t = (i / n) * 4 * Math.PI;
      const noise = 0.1;
      const x = t;
      const y = Math.sin(t) + 0.3 * Math.sin(3 * t) + (Math.random() - 0.5) * noise;
      arr.push({ x, y, original: true });
    }
    return arr;
  };

  // Perform PCA using math (math.eigs exists in mathjs)
  const performPCA = (points) => {
    if (points.length === 0) return null;

    // Convert to matrix (array of arrays)
    const X = points.map(p => [p.x, p.y]);
    const matrix = math.matrix(X);
    
    // Center the data
    const mean = math.mean(matrix, 0);
    const centeredMatrix = math.subtract(matrix, mean);
    
    // Compute covariance matrix
    const n = points.length;
    const covMatrix = math.multiply(math.transpose(centeredMatrix), centeredMatrix);
    const cov = math.divide(covMatrix, n - 1);
    
    // Compute eigenvalues and eigenvectors
    // math.eigs returns { values, vectors } in mathjs
    const eigen = math.eigs(cov);
    const eigenvalues = Array.from(eigen.values);
    const eigenvectors = eigen.vectors; // math.js Matrix

    // Sort indices by eigenvalue magnitude descending
    const sortedIndices = eigenvalues
      .map((val, idx) => ({ val: Math.abs(val), idx }))
      .sort((a, b) => b.val - a.val)
      .map(item => item.idx);
    
    const pc1 = eigenvectors.subset(math.index(math.range(0, 2), sortedIndices[0]));
    const pc2 = eigenvectors.subset(math.index(math.range(0, 2), sortedIndices[1]));
    
    // Project data onto principal components
    const projectedData = points.map(point => {
      const centered = [point.x - mean.get([0]), point.y - mean.get([1])];
      const pc1Score = centered[0] * pc1.get([0]) + centered[1] * pc1.get([1]);
      const pc2Score = centered[0] * pc2.get([0]) + centered[1] * pc2.get([1]);
      return {
        x: pc1Score,
        y: pc2Score,
        original: false
      };
    });
    
    // Calculate explained variance ratio
    const totalVariance = eigenvalues.reduce((sum, val) => sum + Math.abs(val), 0);
    const explainedVariance = sortedIndices.map(idx => 
      (Math.abs(eigenvalues[idx]) / totalVariance * 100).toFixed(1)
    );
    
    return {
      projectedData,
      mean: [mean.get([0]), mean.get([1])],
      pc1: [pc1.get([0]), pc1.get([1])],
      pc2: [pc2.get([0]), pc2.get([1])],
      explainedVariance
    };
  };

  useEffect(() => {
    let newData;
    switch (activeDataset) {
      case 'horseshoe':
        newData = generateHorseshoeData();
        break;
      case 'spiral':
        newData = generateSpiralData();
        break;
      case 'timeseries':
        newData = generateTimeSeriesData();
        break;
      default:
        newData = generateHorseshoeData();
    }
    setData(newData);
    
    if (showPCA) {
      const results = performPCA(newData);
      setPcaResults(results);
    } else {
      setPcaResults(null);
    }
  }, [activeDataset, showPCA]);

  const getDatasetDescription = () => {
    switch (activeDataset) {
      case 'horseshoe':
        return "Horseshoe-shaped data: A classic nonlinear structure where points form a U-shape. PCA will find linear components that don't capture the curved relationship.";
      case 'spiral':
        return "Spiral data: Points follow a spiral pattern in time. PCA fails to capture the circular/spiral structure and temporal relationships.";
      case 'timeseries':
        return "Nonlinear time series: X represents time, Y represents a complex sine wave. PCA treats this as 2D spatial data, missing temporal patterns.";
      default:
        return "";
    }
  };

  const displayData = showPCA && pcaResults ? pcaResults.projectedData : data;
  const xRange = showPCA ? [-3, 3] : activeDataset === 'timeseries' ? [0, 12] : [-3, 3];
  const yRange = showPCA ? [-2, 2] : activeDataset === 'timeseries' ? [-2, 2] : [-1, 3];

  return (
    <div className="p-6 bg-gray-50 min-h-screen">
      <h1 className="text-3xl font-bold mb-6 text-gray-800">How PCA Can Fail: Nonlinear Data Examples</h1>
      <div className="mb-6 bg-white p-4 rounded-lg shadow">
        <h2 className="text-xl font-semibold mb-3">Dataset Selection</h2>
        <div className="flex gap-4 mb-4">
          <button onClick={() => setActiveDataset('horseshoe')}
            className={`px-4 py-2 rounded ${activeDataset === 'horseshoe' ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}>
            Horseshoe Data
          </button>
          <button onClick={() => setActiveDataset('spiral')}
            className={`px-4 py-2 rounded ${activeDataset === 'spiral' ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}>
            Spiral Data
          </button>
          <button onClick={() => setActiveDataset('timeseries')}
            className={`px-4 py-2 rounded ${activeDataset === 'timeseries' ? 'bg-blue-500 text-white' : 'bg-gray-200 hover:bg-gray-300'}`}>
            Time Series Data
          </button>
        </div>
        <div className="mb-4">
          <label className="flex items-center">
            <input type="checkbox" checked={showPCA} onChange={(e) => setShowPCA(e.target.checked)} className="mr-2" />
            Show PCA Projection
          </label>
        </div>
        <p className="text-gray-700">{getDatasetDescription()}</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold mb-3">{showPCA ? 'Data in PCA Space' : 'Original Data'}</h3>
          <div className="w-full h-96 bg-gray-100 rounded flex items-center justify-center">
            <svg width="100%" height="100%" viewBox={`${xRange[0]} ${yRange[0]} ${xRange[1] - xRange[0]} ${yRange[1] - yRange[0]}`}>
              {/* Grid lines */}
              {Array.from({length: 10}, (_, i) => {
                const x = xRange[0] + (i / 9) * (xRange[1] - xRange[0]);
                return <line key={`vline-${i}`} x1={x} y1={yRange[0]} x2={x} y2={yRange[1]} stroke="#e5e7eb" strokeWidth="0.02" />;
              })}
              {Array.from({length: 8}, (_, i) => {
                const y = yRange[0] + (i / 7) * (yRange[1] - yRange[0]);
                return <line key={`hline-${i}`} x1={xRange[0]} y1={y} x2={xRange[1]} y2={y} stroke="#e5e7eb" strokeWidth="0.02" />;
              })}
              
              {/* Data points */}
              {displayData.map((point, i) => (
                <circle key={i} cx={point.x} cy={point.y} r="0.05" fill={showPCA ? "#ef4444" : "#3b82f6"} opacity="0.7" />
              ))}
              
              {/* Principal component axes (only show in original space) */}
              {!showPCA && pcaResults && (
                <>
                  <line x1={pcaResults.mean[0] - pcaResults.pc1[0] * 2} y1={pcaResults.mean[1] - pcaResults.pc1[1] * 2}
                        x2={pcaResults.mean[0] + pcaResults.pc1[0] * 2} y2={pcaResults.mean[1] + pcaResults.pc1[1] * 2}
                        stroke="#dc2626" strokeWidth="0.05" />
                  <line x1={pcaResults.mean[0] - pcaResults.pc2[0] * 1.5} y1={pcaResults.mean[1] - pcaResults.pc2[1] * 1.5}
                        x2={pcaResults.mean[0] + pcaResults.pc2[0] * 1.5} y2={pcaResults.mean[1] + pcaResults.pc2[1] * 1.5}
                        stroke="#dc2626" strokeWidth="0.03" strokeDasharray="0.1,0.05" />
                </>
              )}
            </svg>
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg shadow">
          <h3 className="text-lg font-semibold mb-3">Analysis</h3>
          {showPCA && pcaResults ? (
            <div className="space-y-4">
              <div>
                <h4 className="font-semibold text-red-600">PCA Results:</h4>
                <p className="text-sm">PC1 explains {pcaResults.explainedVariance[0]}% of variance</p>
                <p className="text-sm">PC2 explains {pcaResults.explainedVariance[1]}% of variance</p>
              </div>
              
              <div className="bg-red-50 p-3 rounded">
                <h4 className="font-semibold text-red-700 mb-2">Why PCA Fails:</h4>
                <ul className="text-sm space-y-1">
                  <li>• PCA assumes linear relationships</li>
                  <li>• It finds directions of maximum variance, not structure</li>
                  <li>• Nonlinear patterns are "unfolded" incorrectly</li>
                  <li>• Important relationships are lost in projection</li>
                </ul>
              </div>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="bg-blue-50 p-3 rounded">
                <h4 className="font-semibold text-blue-700 mb-2">Original Data Characteristics:</h4>
                <div className="text-sm space-y-1">
                  {activeDataset === 'horseshoe' && (
                    <>
                      <p>• Clear nonlinear U-shaped structure</p>
                      <p>• Points are intrinsically 1-dimensional</p>
                      <p>• Embedded in 2D space</p>
                    </>
                  )}
                  {activeDataset === 'spiral' && (
                    <>
                      <p>• Spiral structure with time dependency</p>
                      <p>• Circular/rotational patterns</p>
                      <p>• Sequential ordering matters</p>
                    </>
                  )}
                  {activeDataset === 'timeseries' && (
                    <>
                      <p>• Temporal sequence (X = time)</p>
                      <p>• Nonlinear function of time</p>
                      <p>• Multiple frequency components</p>
                    </>
                  )}
                </div>
              </div>
              
              <div className="bg-gray-50 p-3 rounded">
                <h4 className="font-semibold mb-2">Check "Show PCA Projection" to see how PCA fails!</h4>
                <p className="text-sm">PCA will try to find linear components that maximize variance, but will miss the underlying nonlinear structure.</p>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="mt-6 bg-white p-4 rounded-lg shadow">
        <h3 className="text-lg font-semibold mb-3">Key Takeaways</h3>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <h4 className="font-semibold text-green-600 mb-2">When PCA Works Well:</h4>
            <ul className="text-sm space-y-1">
              <li>• Linear relationships between variables</li>
              <li>• Gaussian-distributed data</li>
              <li>• High-dimensional data with linear structure</li>
              <li>• When variance explains meaningful patterns</li>
            </ul>
          </div>
          <div>
            <h4 className="font-semibold text-red-600 mb-2">When PCA Fails:</h4>
            <ul className="text-sm space-y-1">
              <li>• Nonlinear manifolds (like horseshoe, spiral)</li>
              <li>• Time series with temporal dependencies</li>
              <li>• Categorical or discrete data</li>
              <li>• When important patterns have low variance</li>
            </ul>
          </div>
        </div>
        
        <div className="mt-4 p-3 bg-yellow-50 rounded">
          <h4 className="font-semibold text-yellow-700 mb-2">Alternatives to Consider:</h4>
          <p className="text-sm">For nonlinear data: t-SNE, UMAP, Kernel PCA, Autoencoders, or Manifold Learning techniques</p>
        </div>
      </div>
    </div>
  );
}

// Mount the app
const root = ReactDOM.createRoot(document.getElementById('pca-root'));
root.render(<PCAFailureDemo />);
</script>
